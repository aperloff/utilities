#!/usr/bin/env python
import argparse, itertools, os, re
from operator import ior

def endslash_check(string):
	if string!="" and string[-1]=="/": return string
	else: return string+"/"

def isdir(flag):
	return StatInfoFlags.IS_DIR in BiswiseOrOfStatInfoFlags[flag]


def walk(xrdfs, top, depth=0, topdown=True, onerror=None, maxdepth=9999, filename_filter="", fullpath=False, xurl=False):
	"""Directory tree generator for an XRootD file system.

	For each directory in the directory tree rooted at top (including top
	itself, but excluding '.' and '..'), yields a 3-tuple

		dirpath, dirnames, filenames

	dirpath is a string, the path to the directory.  dirnames is a list of
	the names of the subdirectories in dirpath (excluding '.' and '..').
	filenames is a list of the names of the non-directory files in dirpath.
	Note that the names in the lists are just names, with no path components.
	To get a full path (which begins with top) to a file or directory in
	dirpath, do os.path.join(dirpath, name).

	If optional arg 'topdown' is true or not specified, the triple for a
	directory is generated before the triples for any of its subdirectories
	(directories are generated top down).  If topdown is false, the triple
	for a directory is generated after the triples for all of its
	subdirectories (directories are generated bottom up).

	When topdown is true, the caller can modify the dirnames list in-place
	(e.g., via del or slice assignment), and walk will only recurse into the
	subdirectories whose names remain in dirnames; this can be used to prune the
	search, or to impose a specific order of visiting.  Modifying dirnames when
	topdown is false is ineffective, since the directories in dirnames have
	already been generated by the time dirnames itself is generated. No matter
	the value of topdown, the list of subdirectories is retrieved before the
	tuples for the directory and its subdirectories are generated.

	By default errors from the os.listdir() call are ignored.  If
	optional arg 'onerror' is specified, it should be a function; it
	will be called with one argument, an os.error instance.  It can
	report the error to continue with the walk, or raise the exception
	to abort the walk.  Note that the filename is available as the
	filename attribute of the exception object.

	Caution:  if you pass a relative pathname for top, don't change the
	current working directory between resumptions of walk.  walk never
	changes the current directory, and assumes that the client doesn't
	either.

	Example:

	import os
	from os.path import join, getsize
	for root, dirs, files in os.walk('python/Lib/email'):
		print root, "consumes",
		print sum([getsize(join(root, name)) for name in files]),
		print "bytes in", len(files), "non-directory files"
		if 'CVS' in dirs:
			dirs.remove('CVS')  # don't visit CVS directories
	"""

	join = os.path.join

	# We may not have read permission for top, in which case we can't
	# get a list of the files the directory contains.  os.path.walk
	# always suppressed the exception then, rather than blow up for a
	# minor reason when (say) a thousand readable directories are still
	# left to visit.  That logic is copied here.
	try:
		# Note that listdir and error are globals in this module due
		# to earlier import-*.
		names = xrdls(xrdfs,top,False)
	except OSError: #error, err:
		if onerror is not None:
			onerror(OSError)
		return

	dirs, nondirs = [], []
	for name in names:
		#if isdir(join(top, name)):
		if isdir(names[name]):
			dirs.append(endslash_check(name))
		else:
			# filter filenames based on pattern
			if len(re.findall(filename_filter,name))>=1:
				nondirs.append(join(str(xrdfs.url)+top,name) if xurl else join(top,name) if fullpath else name)
			else:
				continue

	if topdown:
		#if depth==0:
		#	dirs = ['']+dirs if xurl or fullpath else ['/']+dirs
		yield str(xrdfs.url)+top if xurl else top, [join(str(xrdfs.url)+top,d) if xurl else join(top,d) if fullpath else d for d in dirs], nondirs
		#if depth == 0:
		#	dirs = dirs[1:]
	for name in dirs:
		new_path = join(top, name)
		if depth<maxdepth:
			for x in walk(xrdfs, new_path, topdown=topdown, depth=depth+1, onerror=onerror, maxdepth=maxdepth, fullpath=fullpath, xurl=xurl):
				yield x
	if not topdown:
		#if depth==0:
		#	dirs = dirs+[''] if xurl or fullpath else dirs+['/']
		yield str(xrdfs.url)+top if xurl else top, [join(str(xrdfs.url)+top,d) if xurl else join(top,d) if fullpath else d for d in dirs], nondirs
		#if depth == 0:
		#	dirs = dirs[:-1]

def xrdls(xrdfs, directory, fullpath=True):
	status, listing = xrdfs.dirlist(directory,DirListFlags.STAT)
	if status.status != 0:
		raise Exception("XRootD failed to stat %s" % directory)
	prefix = directory+"/" if fullpath else ""
	# listing object has more metadata than name
	return {("%s%s" % (prefix, entry.name)) :entry.statinfo.flags for entry in listing}

if __name__ == "__main__":
	# Read parameters
	parser = argparse.ArgumentParser(description="""
Recursively find files and folders in an XRootD based file system.

Dependencies:
  - pyxrootd: Must use CMSSW_9_3_X or higher. Can get around this using something like LCG_94.

Example of how to run:
xrdfs_find.py --help
xrdfs_find.py root://cmseos.fnal.gov/ /store/user/<user>/<path>/
xrdfs_find.py root://cmseos.fnal.gov/ -p /store/user/<user>/<path>/ -n \\bTTJets
""",
									 epilog="",
									 formatter_class=argparse.RawDescriptionHelpFormatter)
	parser.add_argument("xrootd_endpoint",			metavar='mgm-url',		help="XRootD URL of the management server e.g. root://<hostname>[:<port>]")
	parser.add_argument("-b",	"--bottomup",		action="store_true",	help="The default for walk is to go from top down. This replaces that with a bottom up approach. (default = %(default)s)")
	parser.add_argument("-c",	"--count",			action="store_true",	help="Just print global counters for files/dirs found (default = %(default)s)")
	parser.add_argument(		"--childcount",		action="store_true",	help="Print the number of children in each directory (default = %(default)s)")
	parser.add_argument(		"--ignore_cmssw",	action="store_true",	help="Ignore the CMSSW dependency in case using some other source for python with the necessary libraries (default = %(default)s)")
	parser.add_argument("-D",	"--debug",			action="store_true",	help="Print debugging information (default = %(default)s)")
	parser.add_argument("-d",	"--directories",	action="store_true",	help="Find directories in <path> (default = %(default)s)")
	parser.add_argument("-f",	"--files",			action="store_true",	help="Find files in <path> (default = %(default)s)")
	parser.add_argument("-F",	"--fullpath",		action="store_true",	help="Return the full path of the file/folder (default = %(default)s)")
	parser.add_argument("-m",	"--maxdepth",		default=9999, type=int,	help="Descend only <maxdepth> levels (default = %(default)s)")
	parser.add_argument("-n",	"--name",			default="",				help="Find by filename by regex (default = %(default)s)")
	parser.add_argument("-x",	"--xurl",			action="store_true",	help="Print the XRootD URL instead of the path name (default = %(default)s)")
	#parser.add_argument("-g",	"--grep",		default=[],					nargs="+",		help="List of patterns to select for (default = %(default)s)")
	#parser.add_argument("-v",	"--vgrep",		default=[],					nargs="+",		help="List of patterns to ignore (default = %(default)s)")
	parser.add_argument("path",												help="The path in which to search for files and directories")

	args, unknown = parser.parse_known_args()

	# Must use a python release from CMSSW 93X or higher for the pyxrootd bindings
	min_cmssw_version = (9,3,0)
	try:
		cmssw_version = tuple(os.environ['CMSSW_VERSION'].split('_')[1:4])
	except:
		cmssw_version = (0,0,0)
	if cmssw_version < min_cmssw_version and not args.ignore_cmssw:
		raise RuntimeError("Must be using CMSSW_%s_%s_%s or higher to get the pyxrootd bindings. You are currently using CMSSW_%s_%s_%s or some variant." % (min_cmssw_version+cmssw_version))
	else:
		from XRootD import client
		from XRootD.client.flags import DirListFlags, StatInfoFlags, OpenFlags, MkDirFlags, QueryCode
	
	# pyxrootd does not tell you what flags the or'ed value corresponds to
	# Thus we need to form a mappign between the or'ed values and the flags they represent
	code_list = StatInfoFlags.reverse_mapping.keys()
	BiswiseOrOfStatInfoFlags = {0:[0]}
	for n in range(1,8):
		list_of_n_combinations = itertools.combinations(code_list, n)
		for n_combination in list_of_n_combinations:
			current_n_combination = list(n_combination)
			BiswiseOrOfStatInfoFlags[reduce(ior,current_n_combination)] = current_n_combination

	xrdfs = client.FileSystem(args.xrootd_endpoint)

	all_files = []
	all_directories = []

	in_top=False;
	for root, dirs, files in walk(xrdfs,args.path,topdown=not args.bottomup, maxdepth=args.maxdepth,filename_filter=args.name,fullpath=args.fullpath,xurl=args.xurl):
		if root == endslash_check(args.path):
			in_top = True
		else:
			in_top = False

		if args.debug:
			print root
			print dirs
			print files

		if args.files or not (args.files or args.directories):
			all_files += files
		if args.directories or not (args.files or args.directories):
			current_dir = endslash_check(root) if args.xurl or args.fullpath else endslash_check(root.replace(args.path,''))
			all_directories.append((current_dir,len(dirs),len(files)))

	if args.count:
		print "nfiles="+str(len(all_files))+" ndirectories="+str(len(all_directories))
	else:
		if len(all_files) > 0:
			print '\n'.join(map(str,all_files))
		if len(all_directories) > 0:
			if args.childcount:
				print '\n'.join("%s ndir=%i nfiles=%i" % tup for tup in all_directories)
			else:
				print '\n'.join("%s" % tup[0] for tup in all_directories)